<?php

class Twig
{
	protected $_errors = [];
	protected $_path;
	protected $_globalContext;
	/** @var Twig_Context */
	protected $_context;
	protected $_prepared;
	protected $_functionName;
	protected $_source;
	protected $_stripComments;
	protected $_outputMode;
	protected $_encoding;
	protected $_translator;
	protected $_prefilter;
	protected $_postfilter;
	protected $_triggers;
	protected $_codeFile;

	public function __construct($path=false)
	{
		$this->checkInstalled();
		$this->_path = $path;
		$this->_globalContext = new stdClass();
		$this->_context = new Twig_Context();
		$this->_context->setGlobal($this->_globalContext);
	}

	/**
	 * Clone template state and context.
	 */
	public function __clone()
	{
		$context = $this->_context;
		$this->_context = clone $this->_context;
		$this->_context->setParent($context);
		$this->_context->setGlobal($this->_globalContext);
	}

	/**
	 * Set template file path.
	 * @param $path string
	 */
	public function setTemplate($path)
	{
		$this->_prepared = false;
		$this->_functionName = null;
		$this->_path = $path;
		$this->_source = null;
	}

	/**
	 * Set template source.
	 *
	 * Should be used only with temporary template sources, prefer plain
	 * files.
	 *
	 * @param $src string The phptal template source.
	 * @param path string Fake and 'unique' template path.
	 */
	public function setSource($src, $path=false)
	{

	}

	/**
	 * Specify where to look for templates.
	 *
	 * @param $rep mixed string or Array of repositories
	 */
	public function setTemplateRepository($rep)
	{

	}

	/**
	 * Ignore XML/XHTML comments on parsing.
	 * @param $bool bool
	 */
	public function stripComments($bool)
	{
		$this->_stripComments = $bool;
	}

	/**
	 * Set output mode
	 * @param $mode int (PHPTAL::XML or PHPTAL::XHTML).
	 */
	public function setOutputMode($mode=PHPTAL_XHTML)
	{
		$this->_outputMode = $mode;
	}

	/**
	 * Set ouput encoding.
	 * @param $enc string example: 'UTF-8'
	 */
	public function setEncoding($enc)
	{
		$this->_encoding = $enc;
	}

	/**
	 * Set I18N translator.
	 */
	public function setTranslator(PHPTAL_TranslationService $t)
	{
		$this->_translator = $t;
	}

	/**
	 * Set template pre filter.
	 */
	public function setPreFilter(PHPTAL_Filter $filter)
	{
		$this->_prefilter = $filter;
	}

	/**
	 * Set template post filter.
	 */
	public function setPostFilter(PHPTAL_Filter $filter)
	{
		$this->_postfilter = $filter;
	}

	/**
	 * Register a trigger for specified phptal:id.
	 * @param $id string phptal:id to look for
	 */
	public function addTrigger($id, PHPTAL_Trigger $trigger)
	{
		$this->_triggers[$id] = $trigger;
	}

	/**
	 * Returns trigger for specified phptal:id.
	 * @param $id string phptal:id
	 */
	public function getTrigger($id)
	{
		if (array_key_exists($id, $this->_triggers)){
			return $this->_triggers[$id];
		}
		return null;
	}

	/**
	 * Set a context variable.
	 * @param $varname string
	 * @param $value mixed
	 */
	public function __set($varname, $value)
	{
		$this->_context->__set($varname, $value);
	}

	/**
	 * Set a context variable.
	 * @param $varname string
	 * @param $value mixed
	 */
	public function set($varname, $value)
	{
		$this->_context->__set($varname, $value);
	}

	/**
	 * Execute the template code.
	 *
	 * @return string
	 */
	public function execute()
	{
		$this->checkInstalled();

		if (!$this->_prepared) {
			$this->prepare();
		}

		$loader = new Twig_Loader_Filesystem(dirname($this->_path));
		$twig = new Twig_Environment($loader, [
			'debug' => Framework::inDevelopmentMode(),
		]);
		$twig->addExtension(new f_template_TwigExtension());
		if (Framework::inDevelopmentMode()) {
			$twig->addExtension(new f_template_TwigDumpExtension());
		}

		return $twig->render(basename($this->_path), $this->_context->getContext());
	}

	/**
	 * Execute a template macro.
	 * @param $path string Template macro path
	 */
	public function executeMacro($path)
	{
	}

	/**
	 * Prepare template without executing it.
	 */
	public function prepare()
	{
		$this->_prepared = true;
	}

	/**
	 * Returns the path of the intermediate PHP code file.
	 *
	 * The returned file may be used to cleanup (unlink) temporary files
	 * generated by temporary templates or more simply for debug.
	 *
	 * @return string
	 */
	public function getCodePath()
	{
		return $this->_codeFile;
	}

	/**
	 * Returns template translator.
	 * @return PHPTAL_TranslationService
	 */
	public function getTranslator()
	{
		return $this->_translator;
	}

	/**
	 * Returns array of exceptions catched by tal:on-error attribute.
	 * @return array<Exception>
	 */
	public function getErrors()
	{
		return $this->_errors;
	}

	/**
	 * Public for phptal templates, private for user.
	 * @access private
	 */
	public function addError(Exception $error)
	{
		array_push($this->_errors, $error);
	}

	/**
	 * Returns current context object.
	 * @return stdClass
	 */
	public function getContext()
	{
		return $this->_context;
	}

	public function getGlobalContext()
	{
		return $this->_globalContext;
	}

	public function pushContext()
	{
		$this->_context = $this->_context->pushContext();
		return $this->_context;
	}

	public function popContext()
	{
		$this->_context = $this->_context->popContext();
		return $this->_context;
	}

	protected function parse()
	{
	}

	/**
	 * Search template source location.
	 */
	protected function findTemplate()
	{
	}

	/**
	 * Check if Twig is installed
	 */
	protected function checkInstalled()
	{
		if (!class_exists('Twig_Environment')) {
			throw new BaseException('Twig extension is required to render Twig templates.');
		}
	}
}
